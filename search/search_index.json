{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bienvenue sur la doc Plum EcoMAX","text":"<p>Cette int\u00e9gration permet de connecter les chaudi\u00e8res Plum (via le module ecoNET) \u00e0 Home Assistant.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Installez via HACS.</li> <li>Ajoutez l'int\u00e9gration dans Param\u00e8tres &gt; Appareils.</li> </ol>"},{"location":"#fonctionnalites","title":"Fonctionnalit\u00e9s","text":"<ul> <li>Gestion du Chauffage (Climate)</li> <li>Gestion de l'Eau Chaude (Water Heater)</li> <li>Programmation horaire (Calendar)</li> <li>Capteurs de surveillance (Sensor)</li> </ul>"},{"location":"reference/calendar/","title":"Calendar","text":""},{"location":"reference/calendar/#plum_ecomax.calendar","title":"<code>plum_ecomax.calendar</code>","text":""},{"location":"reference/calendar/#plum_ecomax.calendar.PlumEconetCalendar","title":"<code>PlumEconetCalendar</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>CalendarEntity</code></p> <p>Representation of a Plum EcoMAX Calendar.</p> <p>This entity reads binary registers (AM/PM bitmasks) and converts them into readable Home Assistant Calendar events. It supports both heating circuits and domestic hot water (DHW).</p> Source code in <code>custom_components/plum_ecomax/calendar.py</code> <pre><code>class PlumEconetCalendar(CoordinatorEntity, CalendarEntity):\n    \"\"\"Representation of a Plum EcoMAX Calendar.\n\n    This entity reads binary registers (AM/PM bitmasks) and converts them\n    into readable Home Assistant Calendar events. It supports both\n    heating circuits and domestic hot water (DHW).\n    \"\"\"\n\n    def __init__(self, coordinator, entry, system_type: str, index: int):\n        \"\"\"Initializes the calendar entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            entry: The config entry.\n            system_type: The type of system ('circuit' or 'hdw').\n            index: The circuit index (1-7) or 0 for HDW.\n        \"\"\"\n        super().__init__(coordinator)\n        self._entry_id = entry.entry_id\n        self._system_type = system_type  # 'circuit' or 'hdw'\n        self._index = index\n        self._event = None\n\n        if self._system_type == \"circuit\":\n            self._attr_name = f\"Calendar Circuit {index}\"\n            self._attr_unique_id = f\"{DOMAIN}_{entry.entry_id}_calendar_circuit_{index}\"\n        else:\n            self._attr_name = \"DHW Calendar\"\n            self._attr_unique_id = f\"{DOMAIN}_{entry.entry_id}_calendar_hdw\"\n\n    @property\n    def event(self) -&gt; CalendarEvent | None:\n        \"\"\"Returns the next upcoming event.\n\n        Returns:\n            CalendarEvent: The next event, or None if not implemented.\n        \"\"\"\n        return None\n\n    async def async_get_events(\n        self, hass: HomeAssistant, start_date: datetime.datetime, end_date: datetime.datetime\n    ) -&gt; List[CalendarEvent]:\n        \"\"\"Generates events based on the system type.\n\n        Args:\n            hass: Home Assistant instance.\n            start_date: Start of the requested date range.\n            end_date: End of the requested date range.\n\n        Returns:\n            List[CalendarEvent]: A list of calendar events found within the range.\n        \"\"\"\n        events = []\n        current_day = start_date\n\n        while current_day &lt;= end_date:\n            weekday = current_day.weekday()\n            slugs = WEEKDAY_TO_SLUGS.get(weekday)\n\n            if not slugs: \n                current_day += datetime.timedelta(days=1)\n                continue\n\n            suffix_am, suffix_pm = slugs\n\n            if self._system_type == \"circuit\":\n                slug_am = f\"circuit{self._index}{suffix_am}\"\n                slug_pm = f\"circuit{self._index}{suffix_pm}\"\n            else:\n                slug_am = f\"hdw{suffix_am}\"\n                slug_pm = f\"hdw{suffix_pm}\"\n\n            val_am = self.coordinator.data.get(slug_am)\n            val_pm = self.coordinator.data.get(slug_pm)\n\n            if val_am is not None and val_pm is not None:\n                try:\n                    day_events = self._decode_day(current_day, int(val_am), int(val_pm))\n                    events.extend(day_events)\n                except (ValueError, TypeError):\n                    pass\n\n            current_day += datetime.timedelta(days=1)\n\n        return events\n\n    def _decode_day(self, date_base: datetime.datetime, val_am: int, val_pm: int) -&gt; List[CalendarEvent]:\n        \"\"\"Decodes 48-bit binary schedule data for a single day.\n\n        Args:\n            date_base: The base date (00:00).\n            val_am: Integer value of the AM register (00:00-12:00).\n            val_pm: Integer value of the PM register (12:00-00:00).\n\n        Returns:\n            List[CalendarEvent]: List of events derived from the bitmask.\n        \"\"\"\n        events = []\n        slots = []\n        for i in range(24): slots.append((val_am &gt;&gt; i) &amp; 1 == 1)\n        for i in range(24): slots.append((val_pm &gt;&gt; i) &amp; 1 == 1)\n\n        if not slots: return []\n\n        current_start_slot = 0\n        current_state = slots[0]\n\n        for i in range(1, 48):\n            state = slots[i]\n            if state != current_state:\n                events.append(self._create_event(date_base, current_start_slot, i, current_state))\n                current_state = state\n                current_start_slot = i\n\n        events.append(self._create_event(date_base, current_start_slot, 48, current_state))\n        return events\n\n    def _create_event(self, date_base, start_slot, end_slot, is_active) -&gt; CalendarEvent:\n        \"\"\"Creates a Home Assistant CalendarEvent object.\n\n        Args:\n            date_base: The reference date.\n            start_slot: Start index (0-47, representing 30min slots).\n            end_slot: End index (0-48).\n            is_active: Boolean indicating if the slot is Active (Comfort) or Eco.\n\n        Returns:\n            CalendarEvent: The constructed event object.\n        \"\"\"\n        start_h = start_slot // 2\n        start_m = (start_slot % 2) * 30\n        end_h = end_slot // 2\n        end_m = (end_slot % 2) * 30\n\n        dt_start = dt_util.as_local(date_base.replace(hour=int(start_h), minute=int(start_m), second=0, microsecond=0))\n\n        if end_h &gt;= 24:\n            dt_end = dt_util.as_local(date_base.replace(hour=0, minute=0, second=0, microsecond=0) + datetime.timedelta(days=1))\n        else:\n            dt_end = dt_util.as_local(date_base.replace(hour=int(end_h), minute=int(end_m), second=0, microsecond=0))\n\n        if is_active:\n            summary = \"Active\"\n            description = \"Heating/DHW comfort (Day)\"\n        else:\n            summary = \"Eco\"\n            description = \"Heating/DHW eco (Night)\"\n\n        return CalendarEvent(\n            summary=summary,\n            start=dt_start,\n            end=dt_end,\n            description=description\n        )\n\n    @property\n    def device_info(self) -&gt; DeviceInfo:\n        \"\"\"Links the calendar to the correct device registry entry.\n\n        Returns:\n            DeviceInfo: Configuration to link this entity to a circuit or HDW device.\n        \"\"\"\n        if self._system_type == \"circuit\":\n            return DeviceInfo(\n                identifiers={(DOMAIN, f\"{self._entry_id}_circuit_{self._index}\")},\n                name=f\"Circuit {self._index}\",\n                manufacturer=\"Plum\",\n                via_device=(DOMAIN, self._entry_id),\n            )\n        else:\n            return DeviceInfo(\n                identifiers={(DOMAIN, \"plum_hdw\")},\n                name=\"HDW\",\n                manufacturer=\"Plum\",\n                model=\"HDW Monitor\",\n                via_device=(DOMAIN, self._entry_id),\n            )\n</code></pre>"},{"location":"reference/calendar/#plum_ecomax.calendar.PlumEconetCalendar.device_info","title":"<code>device_info</code>  <code>property</code>","text":"<p>Links the calendar to the correct device registry entry.</p> <p>Returns:</p> Name Type Description <code>DeviceInfo</code> <code>DeviceInfo</code> <p>Configuration to link this entity to a circuit or HDW device.</p>"},{"location":"reference/calendar/#plum_ecomax.calendar.PlumEconetCalendar.event","title":"<code>event</code>  <code>property</code>","text":"<p>Returns the next upcoming event.</p> <p>Returns:</p> Name Type Description <code>CalendarEvent</code> <code>CalendarEvent | None</code> <p>The next event, or None if not implemented.</p>"},{"location":"reference/calendar/#plum_ecomax.calendar.PlumEconetCalendar.__init__","title":"<code>__init__(coordinator, entry, system_type, index)</code>","text":"<p>Initializes the calendar entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>entry</code> <p>The config entry.</p> required <code>system_type</code> <code>str</code> <p>The type of system ('circuit' or 'hdw').</p> required <code>index</code> <code>int</code> <p>The circuit index (1-7) or 0 for HDW.</p> required Source code in <code>custom_components/plum_ecomax/calendar.py</code> <pre><code>def __init__(self, coordinator, entry, system_type: str, index: int):\n    \"\"\"Initializes the calendar entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        entry: The config entry.\n        system_type: The type of system ('circuit' or 'hdw').\n        index: The circuit index (1-7) or 0 for HDW.\n    \"\"\"\n    super().__init__(coordinator)\n    self._entry_id = entry.entry_id\n    self._system_type = system_type  # 'circuit' or 'hdw'\n    self._index = index\n    self._event = None\n\n    if self._system_type == \"circuit\":\n        self._attr_name = f\"Calendar Circuit {index}\"\n        self._attr_unique_id = f\"{DOMAIN}_{entry.entry_id}_calendar_circuit_{index}\"\n    else:\n        self._attr_name = \"DHW Calendar\"\n        self._attr_unique_id = f\"{DOMAIN}_{entry.entry_id}_calendar_hdw\"\n</code></pre>"},{"location":"reference/calendar/#plum_ecomax.calendar.PlumEconetCalendar.async_get_events","title":"<code>async_get_events(hass, start_date, end_date)</code>  <code>async</code>","text":"<p>Generates events based on the system type.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>Home Assistant instance.</p> required <code>start_date</code> <code>datetime</code> <p>Start of the requested date range.</p> required <code>end_date</code> <code>datetime</code> <p>End of the requested date range.</p> required <p>Returns:</p> Type Description <code>List[CalendarEvent]</code> <p>List[CalendarEvent]: A list of calendar events found within the range.</p> Source code in <code>custom_components/plum_ecomax/calendar.py</code> <pre><code>async def async_get_events(\n    self, hass: HomeAssistant, start_date: datetime.datetime, end_date: datetime.datetime\n) -&gt; List[CalendarEvent]:\n    \"\"\"Generates events based on the system type.\n\n    Args:\n        hass: Home Assistant instance.\n        start_date: Start of the requested date range.\n        end_date: End of the requested date range.\n\n    Returns:\n        List[CalendarEvent]: A list of calendar events found within the range.\n    \"\"\"\n    events = []\n    current_day = start_date\n\n    while current_day &lt;= end_date:\n        weekday = current_day.weekday()\n        slugs = WEEKDAY_TO_SLUGS.get(weekday)\n\n        if not slugs: \n            current_day += datetime.timedelta(days=1)\n            continue\n\n        suffix_am, suffix_pm = slugs\n\n        if self._system_type == \"circuit\":\n            slug_am = f\"circuit{self._index}{suffix_am}\"\n            slug_pm = f\"circuit{self._index}{suffix_pm}\"\n        else:\n            slug_am = f\"hdw{suffix_am}\"\n            slug_pm = f\"hdw{suffix_pm}\"\n\n        val_am = self.coordinator.data.get(slug_am)\n        val_pm = self.coordinator.data.get(slug_pm)\n\n        if val_am is not None and val_pm is not None:\n            try:\n                day_events = self._decode_day(current_day, int(val_am), int(val_pm))\n                events.extend(day_events)\n            except (ValueError, TypeError):\n                pass\n\n        current_day += datetime.timedelta(days=1)\n\n    return events\n</code></pre>"},{"location":"reference/calendar/#plum_ecomax.calendar.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up Calendar entities for Circuits and DHW.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>The Home Assistant instance.</p> required <code>entry</code> <code>Any</code> <p>The config entry containing the configuration.</p> required <code>async_add_entities</code> <code>AddEntitiesCallback</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/calendar.py</code> <pre><code>async def async_setup_entry(\n    hass: HomeAssistant,\n    entry: Any,\n    async_add_entities: AddEntitiesCallback,\n) -&gt; None:\n    \"\"\"Sets up Calendar entities for Circuits and DHW.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The config entry containing the configuration.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    selected_circuits = entry.data.get(CONF_ACTIVE_CIRCUITS, [])\n    entities = []\n\n    # 1. Circuit's calendar\n    for circuit_id in selected_circuits:\n        if f\"circuit{circuit_id}mondayam\" in coordinator.device.params_map:\n            entities.append(PlumEconetCalendar(coordinator, entry, \"circuit\", circuit_id))\n\n    # 2. HDW's calendar\n    if \"hdwmondayam\" in coordinator.device.params_map:\n        entities.append(PlumEconetCalendar(coordinator, entry, \"hdw\", 0))\n\n    async_add_entities(entities)\n</code></pre>"},{"location":"reference/climate/","title":"Climate","text":""},{"location":"reference/climate/#plum_ecomax.climate","title":"<code>plum_ecomax.climate</code>","text":"<p>Climate platform for the Plum EcoMAX integration.</p> <p>This module handles the thermostat entities for heating circuits, allowing control over target temperatures and HVAC modes (Heat/Off). It supports automatic fallback for temperature sensors if the thermostat sensor is missing.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate","title":"<code>PlumEcomaxClimate</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>ClimateEntity</code></p> <p>Representation of a Plum EcoMAX heating circuit thermostat.</p> <p>This entity controls the heating parameters for a specific circuit. It links to the device coordinator to read/write values such as target temperature and active state.</p> Source code in <code>custom_components/plum_ecomax/climate.py</code> <pre><code>class PlumEcomaxClimate(CoordinatorEntity, ClimateEntity):\n    \"\"\"Representation of a Plum EcoMAX heating circuit thermostat.\n\n    This entity controls the heating parameters for a specific circuit.\n    It links to the device coordinator to read/write values such as\n    target temperature and active state.\n    \"\"\"\n    _attr_has_entity_name = True\n    _attr_temperature_unit = UnitOfTemperature.CELSIUS\n    _attr_supported_features = ClimateEntityFeature.TARGET_TEMPERATURE\n    _attr_hvac_modes = [HVACMode.OFF, HVACMode.HEAT]\n\n    _attr_translation_key = \"thermostat\"\n\n    def __init__(self, coordinator, entry, circuit_id, current_slug, target_slug, active_slug):\n        \"\"\"Initializes the climate entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            entry: The config entry.\n            circuit_id: The ID of the circuit (e.g., 1, 2).\n            current_slug: The slug for the current temperature sensor.\n            target_slug: The slug for the target temperature parameter.\n            active_slug: The slug for the active state parameter.\n        \"\"\"\n        super().__init__(coordinator)\n        self._circuit_id = circuit_id\n        self._entry_id = entry.entry_id\n        self._current_slug = current_slug\n        self._target_slug = target_slug\n        self._active_slug = active_slug\n\n    @property\n    def unique_id(self) -&gt; str:\n        \"\"\"Returns a unique ID for the climate entity.\n\n        Returns:\n            str: The unique identifier string.\n        \"\"\"\n        return f\"{DOMAIN}_{self._entry_id}_circuit_{self._circuit_id}_climate\"\n\n    @property\n    def device_info(self) -&gt; dict:\n        \"\"\"Links the entity to the device registry.\n\n        Returns:\n            dict: Device info dictionary.\n        \"\"\"\n        return {\n            \"identifiers\": {(DOMAIN, f\"{self._entry_id}_circuit_{self._circuit_id}\")},\n            \"name\": f\"Circuit {self._circuit_id}\",\n            \"manufacturer\": \"Plum\",\n            \"model\": \"Heating controller\",\n            \"via_device\": (DOMAIN, self._entry_id),\n        }\n\n    @property\n    def min_temp(self): \n        \"\"\"Returns the minimum target temperature.\"\"\"\n        return 10.0\n    @property\n    def max_temp(self): \n        \"\"\"Returns the maximum target temperature.\"\"\"\n        return 30.0\n    @property\n    def target_temperature_step(self): \n        \"\"\"Returns the step size for target temperature.\"\"\"\n        return 0.5\n\n    @property\n    def current_temperature(self):\n        \"\"\"Returns the current temperature.\n\n        Returns:\n            float | None: The current temperature or None if unavailable.\n        \"\"\"\n        val = self.coordinator.data.get(self._current_slug)\n        return float(val) if val is not None else None\n\n    @property\n    def target_temperature(self):\n        \"\"\"Returns the temperature we try to reach.\n\n        Returns:\n            float: The target temperature.\n        \"\"\"\n        val = self.coordinator.data.get(self._target_slug)\n        if val is None: return 20.0 \n        return float(val)\n\n    @property\n    def hvac_mode(self):\n        \"\"\"Returns current operation mode (Heat or Off).\n\n        Returns:\n            HVACMode: The current mode.\n        \"\"\"\n        is_active = self.coordinator.data.get(self._active_slug)\n        if is_active == 0: return HVACMode.OFF\n        return HVACMode.HEAT\n\n    async def async_set_hvac_mode(self, hvac_mode: HVACMode) -&gt; None:\n        \"\"\"Sets new target operation mode.\n\n        Args:\n            hvac_mode: The desired HVAC mode.\n        \"\"\"\n        value = 1 if hvac_mode == HVACMode.HEAT else 0\n        await self.coordinator.async_set_value(self._active_slug, value)\n\n    async def async_set_temperature(self, **kwargs) -&gt; None:\n        \"\"\"Sets new target temperature.\n\n        If the device is currently Off, it will be switched to Heat mode automatically.\n\n        Args:\n            **kwargs: Keyword arguments containing ATTR_TEMPERATURE.\n        \"\"\"\n        temp = kwargs.get(ATTR_TEMPERATURE)\n        if temp is None:\n            return\n\n        if self.hvac_mode == HVACMode.OFF:\n            await self.async_set_hvac_mode(HVACMode.HEAT)\n\n        await self.coordinator.async_set_value(self._target_slug, temp)\n</code></pre>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.current_temperature","title":"<code>current_temperature</code>  <code>property</code>","text":"<p>Returns the current temperature.</p> <p>Returns:</p> Type Description <p>float | None: The current temperature or None if unavailable.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.device_info","title":"<code>device_info</code>  <code>property</code>","text":"<p>Links the entity to the device registry.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Device info dictionary.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.hvac_mode","title":"<code>hvac_mode</code>  <code>property</code>","text":"<p>Returns current operation mode (Heat or Off).</p> <p>Returns:</p> Name Type Description <code>HVACMode</code> <p>The current mode.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.max_temp","title":"<code>max_temp</code>  <code>property</code>","text":"<p>Returns the maximum target temperature.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.min_temp","title":"<code>min_temp</code>  <code>property</code>","text":"<p>Returns the minimum target temperature.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.target_temperature","title":"<code>target_temperature</code>  <code>property</code>","text":"<p>Returns the temperature we try to reach.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The target temperature.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.target_temperature_step","title":"<code>target_temperature_step</code>  <code>property</code>","text":"<p>Returns the step size for target temperature.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.unique_id","title":"<code>unique_id</code>  <code>property</code>","text":"<p>Returns a unique ID for the climate entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier string.</p>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.__init__","title":"<code>__init__(coordinator, entry, circuit_id, current_slug, target_slug, active_slug)</code>","text":"<p>Initializes the climate entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>entry</code> <p>The config entry.</p> required <code>circuit_id</code> <p>The ID of the circuit (e.g., 1, 2).</p> required <code>current_slug</code> <p>The slug for the current temperature sensor.</p> required <code>target_slug</code> <p>The slug for the target temperature parameter.</p> required <code>active_slug</code> <p>The slug for the active state parameter.</p> required Source code in <code>custom_components/plum_ecomax/climate.py</code> <pre><code>def __init__(self, coordinator, entry, circuit_id, current_slug, target_slug, active_slug):\n    \"\"\"Initializes the climate entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        entry: The config entry.\n        circuit_id: The ID of the circuit (e.g., 1, 2).\n        current_slug: The slug for the current temperature sensor.\n        target_slug: The slug for the target temperature parameter.\n        active_slug: The slug for the active state parameter.\n    \"\"\"\n    super().__init__(coordinator)\n    self._circuit_id = circuit_id\n    self._entry_id = entry.entry_id\n    self._current_slug = current_slug\n    self._target_slug = target_slug\n    self._active_slug = active_slug\n</code></pre>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.async_set_hvac_mode","title":"<code>async_set_hvac_mode(hvac_mode)</code>  <code>async</code>","text":"<p>Sets new target operation mode.</p> <p>Parameters:</p> Name Type Description Default <code>hvac_mode</code> <code>HVACMode</code> <p>The desired HVAC mode.</p> required Source code in <code>custom_components/plum_ecomax/climate.py</code> <pre><code>async def async_set_hvac_mode(self, hvac_mode: HVACMode) -&gt; None:\n    \"\"\"Sets new target operation mode.\n\n    Args:\n        hvac_mode: The desired HVAC mode.\n    \"\"\"\n    value = 1 if hvac_mode == HVACMode.HEAT else 0\n    await self.coordinator.async_set_value(self._active_slug, value)\n</code></pre>"},{"location":"reference/climate/#plum_ecomax.climate.PlumEcomaxClimate.async_set_temperature","title":"<code>async_set_temperature(**kwargs)</code>  <code>async</code>","text":"<p>Sets new target temperature.</p> <p>If the device is currently Off, it will be switched to Heat mode automatically.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments containing ATTR_TEMPERATURE.</p> <code>{}</code> Source code in <code>custom_components/plum_ecomax/climate.py</code> <pre><code>async def async_set_temperature(self, **kwargs) -&gt; None:\n    \"\"\"Sets new target temperature.\n\n    If the device is currently Off, it will be switched to Heat mode automatically.\n\n    Args:\n        **kwargs: Keyword arguments containing ATTR_TEMPERATURE.\n    \"\"\"\n    temp = kwargs.get(ATTR_TEMPERATURE)\n    if temp is None:\n        return\n\n    if self.hvac_mode == HVACMode.OFF:\n        await self.async_set_hvac_mode(HVACMode.HEAT)\n\n    await self.coordinator.async_set_value(self._target_slug, temp)\n</code></pre>"},{"location":"reference/climate/#plum_ecomax.climate.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up Plum EcoMAX climate entities based on the config entry.</p> <p>This function dynamically creates climate entities for each active circuit defined in the configuration. It implements a fallback mechanism for the current temperature sensor: if the thermostat sensor is unavailable, it uses the circuit temperature sensor instead.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <p>The Home Assistant instance.</p> required <code>entry</code> <p>The configuration entry.</p> required <code>async_add_entities</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/climate.py</code> <pre><code>async def async_setup_entry(hass, entry, async_add_entities):\n    \"\"\"Sets up Plum EcoMAX climate entities based on the config entry.\n\n    This function dynamically creates climate entities for each active circuit\n    defined in the configuration. It implements a fallback mechanism for the\n    current temperature sensor: if the thermostat sensor is unavailable,\n    it uses the circuit temperature sensor instead.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The configuration entry.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    selected_circuits = entry.data.get(CONF_ACTIVE_CIRCUITS, [])\n    entities = []\n\n    for circuit_id in selected_circuits:\n        current_slug = f\"circuit{circuit_id}thermostattemp\"\n        target_slug = f\"circuit{circuit_id}comforttemp\"\n        active_slug = f\"circuit{circuit_id}active\"\n\n        # Fallback sensor\n        if current_slug not in coordinator.device.params_map:\n             current_slug = f\"tempcircuit{circuit_id}\"\n\n        if target_slug in coordinator.device.params_map:\n             entities.append(PlumEcomaxClimate(\n                 coordinator, entry, circuit_id, current_slug, target_slug, active_slug\n            ))\n\n    if entities:\n        async_add_entities(entities)\n</code></pre>"},{"location":"reference/coordinator/","title":"Coordinateur","text":""},{"location":"reference/coordinator/#plum_ecomax.coordinator","title":"<code>plum_ecomax.coordinator</code>","text":"<p>Data Update Coordinator for Plum EcoMAX.</p> <p>This module provides the central data management logic for the integration. It handles polling, caching, validation, and a robust \"fire-and-forget\" write strategy to ensure commands reach the device despite network latency.</p>"},{"location":"reference/coordinator/#plum_ecomax.coordinator.PlumDataUpdateCoordinator","title":"<code>PlumDataUpdateCoordinator</code>","text":"<p>               Bases: <code>DataUpdateCoordinator</code></p> <p>Centralized data management with Robust Data Validation.</p> <p>Implements caching, write-through strategies, and data sanitization to prevent outliers from polluting the state machine.</p> Source code in <code>custom_components/plum_ecomax/coordinator.py</code> <pre><code>class PlumDataUpdateCoordinator(DataUpdateCoordinator):\n    \"\"\"Centralized data management with Robust Data Validation.\n\n    Implements caching, write-through strategies, and data sanitization\n    to prevent outliers from polluting the state machine.\n    \"\"\"\n\n    def __init__(self, hass: HomeAssistant, device: \"PlumDevice\"):\n        \"\"\"Initializes the coordinator.\n\n        Args:\n            hass: Home Assistant core instance.\n            device: The low-level PlumDevice instance.\n        \"\"\"\n        self.device = device\n        self.available_slugs: list[str] = []\n\n        # Cache System\n        self._cache: Dict[str, Any] = {}\n        self._timestamps: Dict[str, float] = {}\n        self._cache_lock = asyncio.Lock()\n        self.ttl = DEFAULT_TTL\n\n        super().__init__(\n            hass,\n            _LOGGER,\n            name=DOMAIN,\n            update_interval=timedelta(seconds=UPDATE_INTERVAL),\n        )\n\n    async def _async_update_data(self) -&gt; Dict[str, Any]:\n        \"\"\"Main update loop with Validation and Fallback.\n\n        Returns:\n            dict: The validated data.\n        \"\"\"\n        data = {}\n        now = time.time()\n\n        if not self.available_slugs:\n            await self._detect_available_parameters()\n\n        for slug in self.available_slugs:\n            async with self._cache_lock:\n                last_update = self._timestamps.get(slug, 0)\n                is_fresh = (now - last_update) &lt; self.ttl\n                cached_val = self._cache.get(slug)\n\n            # 1. Cache Hit\n            if is_fresh and cached_val is not None:\n                data[slug] = cached_val\n                continue\n\n            # 2. Fetch &amp; Validate\n            try:\n                raw_val = await self.device.get_value(slug, retries=2)\n\n                # --- VALIDATION STEP ---\n                is_valid, final_val = self._validate_value(slug, raw_val, cached_val)\n\n                if is_valid:\n                    # Valid new data: Update cache\n                    async with self._cache_lock:\n                        self._cache[slug] = final_val\n                        self._timestamps[slug] = time.time()\n                    data[slug] = final_val\n                else:\n                    # Invalid data: Use fallback (Hold Last State)\n                    if cached_val is not None:\n                        data[slug] = cached_val\n\n            except Exception as e:\n                _LOGGER.warning(f\"Error reading {slug}: {e}\")\n                if slug in self._cache:\n                    data[slug] = self._cache[slug]\n\n        return data\n\n    def _validate_value(self, slug: str, raw_val: Any, cached_val: Any) -&gt; Tuple[bool, Any]:\n        \"\"\"Sanitizes the raw value based on JSON limits or Generic constraints.\n\n        Args:\n            slug: The parameter identifier.\n            raw_val: The raw value received.\n            cached_val: The previous value (for delta checking).\n\n        Returns:\n            Tuple[bool, Any]: (IsValid, SafeValue).\n        \"\"\"\n        # A. Basic protocol checks\n        if raw_val is None:\n            return False, None\n\n        if isinstance(raw_val, (int, float)):\n            if raw_val == 999.0 or raw_val == 999:\n                _LOGGER.debug(f\"\u26a0\ufe0f Rejection: {slug} returned sensor error code {raw_val}\")\n                return False, None\n\n        param_def = self.device.params_map.get(slug, {})\n        json_min = param_def.get(\"min\")\n        json_max = param_def.get(\"max\")\n        json_max_delta = param_def.get(\"max_delta\")\n\n        # B. Specific bounds check (JSON)\n        if (json_min is not None or json_max is not None) and isinstance(raw_val, (int, float)):\n            is_valid = True\n\n            if json_min is not None and raw_val &lt; json_min:\n                is_valid = False\n            if json_max is not None and raw_val &gt; json_max:\n                is_valid = False\n            # Fix typo from original code: is_valide -&gt; is_valid\n            if json_max_delta is not None and cached_val is not None and abs(cached_val - raw_val) &gt; json_max_delta:\n                is_valid = False\n\n            if not is_valid:\n                return False, None\n\n            return True, raw_val\n\n        # C. Generic bounds check (Fallback)\n        if isinstance(raw_val, (int, float)):\n            for keyword, (min_v, max_v) in VALIDATION_RANGES.items():\n                if keyword in slug:\n                    if not (min_v &lt;= raw_val &lt;= max_v):\n                        return False, None\n                    break \n\n        return True, raw_val\n\n\n    async def async_set_value(self, slug: str, value: Any) -&gt; bool:\n        \"\"\"Writes a value using Optimistic UI + Repeated Background Sends.\n\n        1. Updates the internal cache immediately so the UI is responsive.\n        2. Launches a background task to send the command 5 times to ensure\n           reception by the hardware.\n\n        Args:\n            slug: The parameter identifier.\n            value: The value to write.\n\n        Returns:\n            bool: Always True (Optimistic).\n        \"\"\"\n        # 1. Optimistic Cache Update (Immediate)\n        async with self._cache_lock:\n            self._cache[slug] = value\n            self._timestamps[slug] = time.time()\n\n        # Notify Home Assistant immediately\n        self.async_set_updated_data(self._cache)\n        _LOGGER.info(f\"\u2705 Optimistic set for {slug}={value}. Launching background sends.\")\n\n        # 2. Launch background task for repeated sending\n        # This prevents blocking the UI or the event loop\n        asyncio.create_task(self._perform_repeated_write(slug, value))\n\n        return True\n\n    async def _perform_repeated_write(self, slug: str, value: Any) -&gt; None:\n        \"\"\"Background task to spam the write command.\n\n        Sends the command 5 times with a 2-second interval.\n\n        Args:\n            slug: Parameter slug.\n            value: Value to write.\n        \"\"\"\n        for i in range(1, 6): # 5 attempts\n            _LOGGER.debug(f\"\ud83d\udce4 Sending {slug}={value} (Attempt {i}/5)\")\n            await self.device.set_value(slug, value)\n\n            # Wait 2 seconds between sends, but not after the last one\n            if i &lt; 5:\n                await asyncio.sleep(2.0)\n\n    async def _detect_available_parameters(self) -&gt; None:\n        \"\"\"Initial scan to filter out unsupported parameters.\"\"\"\n        _LOGGER.info(\"\ud83d\udd0d Initial scan of available parameters...\")\n\n        targets = []\n        targets.extend(list(SENSOR_TYPES.keys()))\n        for conf in CLIMATE_TYPES.values(): targets.extend(conf) \n        targets.extend(list(NUMBER_TYPES.keys()))\n        for conf in WATER_HEATER_TYPES.values(): targets.extend(conf)\n        # Added Schedule types to detection\n        targets.extend(list(SCHEDULE_TYPES.keys()))\n\n        valid_slugs = []\n        for slug in targets:\n            if slug not in self.device.params_map:\n                continue\n\n            val = await self.device.get_value(slug, retries=5)\n\n            # Filter invalid values (999.0 often indicates a disconnected probe)\n            if val is not None and val != 999.0:\n                 valid_slugs.append(slug)\n\n        self.available_slugs = list(set(valid_slugs))\n        _LOGGER.info(f\"\u2705 {len(self.available_slugs)} active parameters retained.\")\n</code></pre>"},{"location":"reference/coordinator/#plum_ecomax.coordinator.PlumDataUpdateCoordinator.__init__","title":"<code>__init__(hass, device)</code>","text":"<p>Initializes the coordinator.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>Home Assistant core instance.</p> required <code>device</code> <code>PlumDevice</code> <p>The low-level PlumDevice instance.</p> required Source code in <code>custom_components/plum_ecomax/coordinator.py</code> <pre><code>def __init__(self, hass: HomeAssistant, device: \"PlumDevice\"):\n    \"\"\"Initializes the coordinator.\n\n    Args:\n        hass: Home Assistant core instance.\n        device: The low-level PlumDevice instance.\n    \"\"\"\n    self.device = device\n    self.available_slugs: list[str] = []\n\n    # Cache System\n    self._cache: Dict[str, Any] = {}\n    self._timestamps: Dict[str, float] = {}\n    self._cache_lock = asyncio.Lock()\n    self.ttl = DEFAULT_TTL\n\n    super().__init__(\n        hass,\n        _LOGGER,\n        name=DOMAIN,\n        update_interval=timedelta(seconds=UPDATE_INTERVAL),\n    )\n</code></pre>"},{"location":"reference/coordinator/#plum_ecomax.coordinator.PlumDataUpdateCoordinator.async_set_value","title":"<code>async_set_value(slug, value)</code>  <code>async</code>","text":"<p>Writes a value using Optimistic UI + Repeated Background Sends.</p> <ol> <li>Updates the internal cache immediately so the UI is responsive.</li> <li>Launches a background task to send the command 5 times to ensure    reception by the hardware.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>The parameter identifier.</p> required <code>value</code> <code>Any</code> <p>The value to write.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always True (Optimistic).</p> Source code in <code>custom_components/plum_ecomax/coordinator.py</code> <pre><code>async def async_set_value(self, slug: str, value: Any) -&gt; bool:\n    \"\"\"Writes a value using Optimistic UI + Repeated Background Sends.\n\n    1. Updates the internal cache immediately so the UI is responsive.\n    2. Launches a background task to send the command 5 times to ensure\n       reception by the hardware.\n\n    Args:\n        slug: The parameter identifier.\n        value: The value to write.\n\n    Returns:\n        bool: Always True (Optimistic).\n    \"\"\"\n    # 1. Optimistic Cache Update (Immediate)\n    async with self._cache_lock:\n        self._cache[slug] = value\n        self._timestamps[slug] = time.time()\n\n    # Notify Home Assistant immediately\n    self.async_set_updated_data(self._cache)\n    _LOGGER.info(f\"\u2705 Optimistic set for {slug}={value}. Launching background sends.\")\n\n    # 2. Launch background task for repeated sending\n    # This prevents blocking the UI or the event loop\n    asyncio.create_task(self._perform_repeated_write(slug, value))\n\n    return True\n</code></pre>"},{"location":"reference/number/","title":"Number","text":""},{"location":"reference/number/#plum_ecomax.number","title":"<code>plum_ecomax.number</code>","text":"<p>Number platform for the Plum EcoMAX integration.</p> <p>This module provides number entities for configurable numerical parameters of the boiler, such as hysteresis, target temperatures (if not covered by climate), or other adjustable settings defined in <code>NUMBER_TYPES</code>.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber","title":"<code>PlumEcomaxNumber</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>NumberEntity</code></p> <p>Representation of a Plum EcoMAX numerical parameter.</p> <p>This entity allows the user to adjust a numerical value (e.g., setpoint, hysteresis) within a defined range (min, max, step). It reflects changes immediately in the UI via the coordinator's optimistic update logic.</p> Source code in <code>custom_components/plum_ecomax/number.py</code> <pre><code>class PlumEcomaxNumber(CoordinatorEntity, NumberEntity):\n    \"\"\"Representation of a Plum EcoMAX numerical parameter.\n\n    This entity allows the user to adjust a numerical value (e.g., setpoint,\n    hysteresis) within a defined range (min, max, step). It reflects changes\n    immediately in the UI via the coordinator's optimistic update logic.\n    \"\"\"\n    _attr_has_entity_name = True \n\n    def __init__(self, coordinator, entry, slug, config):\n        \"\"\"Initializes the number entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            entry: The config entry.\n            slug: The parameter identifier string.\n            config: A tuple containing (min, max, step, icon).\n        \"\"\"\n        super().__init__(coordinator)\n        self._slug = slug\n\n        # --- INDEX CHANGE ---\n        self._min_val = config[0]\n        self._max_val = config[1]\n        self._step_val = config[2]\n        self._icon_val = config[3]\n\n        self._entry_id = entry.entry_id\n        self._attr_translation_key = slug\n\n    @property\n    def unique_id(self) -&gt; str:\n        \"\"\"Returns the unique ID of the entity.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return f\"{DOMAIN}_{self._entry_id}_number_{self._slug}\"\n\n    @property\n    def native_value(self):\n        \"\"\"Returns the current value of the number.\n\n        Returns:\n            float | None: The current value or None if unavailable.\n        \"\"\"\n        val = self.coordinator.data.get(self._slug)\n        return float(val) if val is not None else None\n\n    @property\n    def native_min_value(self) -&gt; float:\n        \"\"\"Returns the minimum allowed value.\"\"\"\n        return self._min_val\n\n    @property\n    def native_max_value(self) -&gt; float:\n        \"\"\"Returns the maximum allowed value.\"\"\"\n        return self._max_val\n\n    @property\n    def native_step(self) -&gt; float:\n        \"\"\"Returns the step increment.\"\"\"\n        return self._step_val\n\n    @property\n    def icon(self) -&gt; str:\n        \"\"\"Returns the icon for the entity.\"\"\"\n        return self._icon_val\n\n    async def async_set_native_value(self, value: float) -&gt; None:\n        \"\"\"Sets a new value for the entity.\n\n        Args:\n            value: The new value to set.\n        \"\"\"\n        await self.coordinator.async_set_value(self._slug, int(value))\n</code></pre>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.icon","title":"<code>icon</code>  <code>property</code>","text":"<p>Returns the icon for the entity.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.native_max_value","title":"<code>native_max_value</code>  <code>property</code>","text":"<p>Returns the maximum allowed value.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.native_min_value","title":"<code>native_min_value</code>  <code>property</code>","text":"<p>Returns the minimum allowed value.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.native_step","title":"<code>native_step</code>  <code>property</code>","text":"<p>Returns the step increment.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.native_value","title":"<code>native_value</code>  <code>property</code>","text":"<p>Returns the current value of the number.</p> <p>Returns:</p> Type Description <p>float | None: The current value or None if unavailable.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.unique_id","title":"<code>unique_id</code>  <code>property</code>","text":"<p>Returns the unique ID of the entity.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.__init__","title":"<code>__init__(coordinator, entry, slug, config)</code>","text":"<p>Initializes the number entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>entry</code> <p>The config entry.</p> required <code>slug</code> <p>The parameter identifier string.</p> required <code>config</code> <p>A tuple containing (min, max, step, icon).</p> required Source code in <code>custom_components/plum_ecomax/number.py</code> <pre><code>def __init__(self, coordinator, entry, slug, config):\n    \"\"\"Initializes the number entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        entry: The config entry.\n        slug: The parameter identifier string.\n        config: A tuple containing (min, max, step, icon).\n    \"\"\"\n    super().__init__(coordinator)\n    self._slug = slug\n\n    # --- INDEX CHANGE ---\n    self._min_val = config[0]\n    self._max_val = config[1]\n    self._step_val = config[2]\n    self._icon_val = config[3]\n\n    self._entry_id = entry.entry_id\n    self._attr_translation_key = slug\n</code></pre>"},{"location":"reference/number/#plum_ecomax.number.PlumEcomaxNumber.async_set_native_value","title":"<code>async_set_native_value(value)</code>  <code>async</code>","text":"<p>Sets a new value for the entity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The new value to set.</p> required Source code in <code>custom_components/plum_ecomax/number.py</code> <pre><code>async def async_set_native_value(self, value: float) -&gt; None:\n    \"\"\"Sets a new value for the entity.\n\n    Args:\n        value: The new value to set.\n    \"\"\"\n    await self.coordinator.async_set_value(self._slug, int(value))\n</code></pre>"},{"location":"reference/number/#plum_ecomax.number.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up Plum EcoMAX number entities.</p> <p>Iterates through the <code>NUMBER_TYPES</code> configuration and creates an entity if the corresponding parameter exists on the device.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <p>The Home Assistant instance.</p> required <code>entry</code> <p>The configuration entry.</p> required <code>async_add_entities</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/number.py</code> <pre><code>async def async_setup_entry(hass, entry, async_add_entities):\n    \"\"\"Sets up Plum EcoMAX number entities.\n\n    Iterates through the `NUMBER_TYPES` configuration and creates an entity\n    if the corresponding parameter exists on the device.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The configuration entry.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    entities = []\n    for slug, config in NUMBER_TYPES.items():\n        if slug in coordinator.device.params_map:\n            entities.append(PlumEcomaxNumber(coordinator, entry, slug, config))\n    if entities:\n        async_add_entities(entities)\n</code></pre>"},{"location":"reference/select/","title":"Select","text":""},{"location":"reference/select/#plum_ecomax.select","title":"<code>plum_ecomax.select</code>","text":"<p>Select platform for the Plum EcoMAX integration.</p> <p>This module handles dropdown selection entities (SelectEntity). It is used for parameters that have a discrete set of options, such as the DHW mode (Off, Manual, Auto) or other enumerated settings.</p>"},{"location":"reference/select/#plum_ecomax.select.PlumEconetSelect","title":"<code>PlumEconetSelect</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>SelectEntity</code></p> <p>Representation of a multi-choice parameter (Enum).</p> <p>This entity represents a selectable parameter on the Plum device, mapping internal integer values to human-readable string options (e.g., mapping 0-&gt;'Off', 1-&gt;'Manual').</p> Source code in <code>custom_components/plum_ecomax/select.py</code> <pre><code>class PlumEconetSelect(CoordinatorEntity, SelectEntity):\n    \"\"\"Representation of a multi-choice parameter (Enum).\n\n    This entity represents a selectable parameter on the Plum device,\n    mapping internal integer values to human-readable string options\n    (e.g., mapping 0-&gt;'Off', 1-&gt;'Manual').\n    \"\"\"\n    _attr_has_entity_name = True\n\n    def __init__(self, coordinator, slug: str, name: str, map_to_ha: Dict[int, str], map_to_plum: Dict[str, int]):\n        \"\"\"Initializes the select entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            slug: The parameter identifier string.\n            name: The friendly name of the entity.\n            map_to_ha: Dictionary mapping Integer (Plum) -&gt; String (Home Assistant).\n            map_to_plum: Dictionary mapping String (Home Assistant) -&gt; Integer (Plum).\n        \"\"\"\n        super().__init__(coordinator)\n        self._slug = slug\n        self._log_name = name\n        self._attr_translation_key = slug\n        self._attr_unique_id = f\"{DOMAIN}_{slug}\"\n\n        self._map_to_ha = map_to_ha\n        self._map_to_plum = map_to_plum\n\n        # Define available options based on the mapping keys\n        self._attr_options = list(map_to_plum.keys())\n\n    @property\n    def current_option(self) -&gt; str | None:\n        \"\"\"Returns the currently selected option.\n\n        Converts the raw integer value received from the device into a\n        human-readable string using the internal mapping.\n\n        Returns:\n            str | None: The selected option string, or None if unknown.\n        \"\"\"\n        raw_val = self.coordinator.data.get(self._slug)\n        try:\n            raw_int = int(raw_val)\n            return self._map_to_ha.get(raw_int)\n        except (ValueError, TypeError):\n            return None\n\n    async def async_select_option(self, option: str) -&gt; None:\n        \"\"\"Updates the selected option.\n\n        Converts the selected string back to the corresponding integer value\n        and writes it to the device via the coordinator.\n\n        Args:\n            option: The option selected by the user.\n        \"\"\"\n        target_val = self._map_to_plum.get(option)\n\n        if target_val is not None:\n            _LOGGER.info(f\"Setting {self._log_name} to {option} (Raw: {target_val})\")\n            await self.coordinator.async_set_value(self._slug, target_val)\n        else:\n            _LOGGER.error(f\"Invalid option '{option}' for {self._slug}\")\n</code></pre>"},{"location":"reference/select/#plum_ecomax.select.PlumEconetSelect.current_option","title":"<code>current_option</code>  <code>property</code>","text":"<p>Returns the currently selected option.</p> <p>Converts the raw integer value received from the device into a human-readable string using the internal mapping.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The selected option string, or None if unknown.</p>"},{"location":"reference/select/#plum_ecomax.select.PlumEconetSelect.__init__","title":"<code>__init__(coordinator, slug, name, map_to_ha, map_to_plum)</code>","text":"<p>Initializes the select entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>slug</code> <code>str</code> <p>The parameter identifier string.</p> required <code>name</code> <code>str</code> <p>The friendly name of the entity.</p> required <code>map_to_ha</code> <code>Dict[int, str]</code> <p>Dictionary mapping Integer (Plum) -&gt; String (Home Assistant).</p> required <code>map_to_plum</code> <code>Dict[str, int]</code> <p>Dictionary mapping String (Home Assistant) -&gt; Integer (Plum).</p> required Source code in <code>custom_components/plum_ecomax/select.py</code> <pre><code>def __init__(self, coordinator, slug: str, name: str, map_to_ha: Dict[int, str], map_to_plum: Dict[str, int]):\n    \"\"\"Initializes the select entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        slug: The parameter identifier string.\n        name: The friendly name of the entity.\n        map_to_ha: Dictionary mapping Integer (Plum) -&gt; String (Home Assistant).\n        map_to_plum: Dictionary mapping String (Home Assistant) -&gt; Integer (Plum).\n    \"\"\"\n    super().__init__(coordinator)\n    self._slug = slug\n    self._log_name = name\n    self._attr_translation_key = slug\n    self._attr_unique_id = f\"{DOMAIN}_{slug}\"\n\n    self._map_to_ha = map_to_ha\n    self._map_to_plum = map_to_plum\n\n    # Define available options based on the mapping keys\n    self._attr_options = list(map_to_plum.keys())\n</code></pre>"},{"location":"reference/select/#plum_ecomax.select.PlumEconetSelect.async_select_option","title":"<code>async_select_option(option)</code>  <code>async</code>","text":"<p>Updates the selected option.</p> <p>Converts the selected string back to the corresponding integer value and writes it to the device via the coordinator.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>The option selected by the user.</p> required Source code in <code>custom_components/plum_ecomax/select.py</code> <pre><code>async def async_select_option(self, option: str) -&gt; None:\n    \"\"\"Updates the selected option.\n\n    Converts the selected string back to the corresponding integer value\n    and writes it to the device via the coordinator.\n\n    Args:\n        option: The option selected by the user.\n    \"\"\"\n    target_val = self._map_to_plum.get(option)\n\n    if target_val is not None:\n        _LOGGER.info(f\"Setting {self._log_name} to {option} (Raw: {target_val})\")\n        await self.coordinator.async_set_value(self._slug, target_val)\n    else:\n        _LOGGER.error(f\"Invalid option '{option}' for {self._slug}\")\n</code></pre>"},{"location":"reference/select/#plum_ecomax.select.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up Plum select entities (Dropdowns).</p> <p>Iterates through the <code>SELECT_TYPES</code> configuration and creates an entity if the corresponding parameter exists on the device.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>The Home Assistant instance.</p> required <code>entry</code> <code>ConfigEntry</code> <p>The configuration entry.</p> required <code>async_add_entities</code> <code>AddEntitiesCallback</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/select.py</code> <pre><code>async def async_setup_entry(\n    hass: HomeAssistant,\n    entry: ConfigEntry,\n    async_add_entities: AddEntitiesCallback,\n) -&gt; None:\n    \"\"\"Sets up Plum select entities (Dropdowns).\n\n    Iterates through the `SELECT_TYPES` configuration and creates an entity\n    if the corresponding parameter exists on the device.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The configuration entry.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    entities = []\n\n    # Config format: \"slug\": (\"Name\", Map_To_HA, Map_To_Plum)\n    for slug, (name, map_to_ha, map_to_plum) in SELECT_TYPES.items():\n        if slug in coordinator.device.params_map:\n            entities.append(PlumEconetSelect(coordinator, slug, name, map_to_ha, map_to_plum))\n        else:\n            _LOGGER.debug(f\"Select '{slug}' not found in device map, skipping.\")\n\n    async_add_entities(entities)\n</code></pre>"},{"location":"reference/sensor/","title":"Sensor","text":""},{"location":"reference/sensor/#plum_ecomax.sensor","title":"<code>plum_ecomax.sensor</code>","text":"<p>Sensor platform for the Plum EcoMAX integration.</p> <p>This module handles the creation and management of sensor entities. It automatically detects which circuit a sensor belongs to (using regex) and attaches it to the correct device in Home Assistant.</p> <p>It also implements critical safety checks to handle 'NaN' (Not a Number) values that might be returned by the boiler during initialization or errors.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor","title":"<code>PlumEcomaxSensor</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>SensorEntity</code></p> <p>Representation of a Plum sensor entity with NaN protection.</p> <p>This entity handles both numeric and text sensors. For numeric sensors, it explicitly checks for valid float values and filters out NaN/Infinity to prevent errors in Home Assistant's recorder.</p> Source code in <code>custom_components/plum_ecomax/sensor.py</code> <pre><code>class PlumEcomaxSensor(CoordinatorEntity, SensorEntity):\n    \"\"\"Representation of a Plum sensor entity with NaN protection.\n\n    This entity handles both numeric and text sensors. For numeric sensors,\n    it explicitly checks for valid float values and filters out\n    NaN/Infinity to prevent errors in Home Assistant's recorder.\n    \"\"\"\n\n    _attr_has_entity_name = True\n\n    def __init__(self, coordinator, entry, slug, config, circuit_id=None):\n        \"\"\"Initializes the sensor.\n\n        Args:\n            coordinator: The data update coordinator.\n            entry: The config entry.\n            slug: The parameter identifier.\n            config: A tuple containing (unit, icon, device_class).\n            circuit_id: Optional ID to link to a specific circuit device.\n        \"\"\"\n        super().__init__(coordinator)\n        self._slug = slug\n        self._attr_translation_key = slug\n\n        # Unpack configuration from const.py\n        self._unit = config[0]\n        self._icon = config[1]\n        self._device_class = config[2]\n\n        self._entry_id = entry.entry_id\n        self._circuit_id = circuit_id\n\n    @property\n    def unique_id(self) -&gt; str:\n        \"\"\"Returns the unique ID of the sensor.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return f\"{DOMAIN}_{self._entry_id}_{self._slug}\"\n\n    @property\n    def native_value(self) -&gt; float | str | None:\n        \"\"\"Returns the sensor value with safety checks.\n\n        CRITICAL FIX: Filters out 'NaN' (Not a Number) values to prevent HA crash.\n\n        Returns:\n            float | str | None: The sanitized value.\n        \"\"\"\n        val = self.coordinator.data.get(self._slug)\n\n        if val is None:\n            return None\n\n        # If a Device Class or Unit is defined, we expect a number\n        if self._device_class or self._unit:\n            try:\n                f_val = float(val)\n                # Check if value is NaN or Infinite -&gt; Return None (Unavailable)\n                if math.isnan(f_val) or math.isinf(f_val):\n                    return None\n                return f_val\n            except (ValueError, TypeError):\n                # Conversion failed but a number was expected -&gt; Return None\n                return None\n\n        # For text sensors, return the value as is\n        return val\n\n    @property\n    def available(self) -&gt; bool:\n        \"\"\"Checks if the entity is available.\n\n        Returns:\n            bool: False if data is missing or NaN, True otherwise.\n        \"\"\"\n        val = self.coordinator.data.get(self._slug)\n        if val is None:\n            return False\n\n        # If it's a number, check for NaN\n        if isinstance(val, float) and math.isnan(val):\n            return False\n\n        return super().available\n\n    @property\n    def native_unit_of_measurement(self) -&gt; str | None:\n        \"\"\"Returns the unit of measurement.\"\"\"\n        return self._unit\n\n    @property\n    def icon(self) -&gt; str | None:\n        \"\"\"Returns the icon.\"\"\"\n        return self._icon\n\n    @property\n    def device_class(self) -&gt; str | None:\n        \"\"\"Returns the device class.\"\"\"\n        return self._device_class\n\n    @property\n    def state_class(self) -&gt; SensorStateClass | None:\n        \"\"\"Returns the state class (Measurement for numbers).\"\"\"\n        # Only set state_class for numeric sensors\n        if self._device_class or self._unit:\n            return SensorStateClass.MEASUREMENT\n        return None\n\n    @property\n    def device_info(self) -&gt; dict:\n        \"\"\"Links the sensor to the correct device (Boiler or specific Circuit).\n\n        Returns:\n            dict: The device info dictionary.\n        \"\"\"\n        if self._circuit_id:\n            return {\n                \"identifiers\": {(DOMAIN, f\"{self._entry_id}_circuit_{self._circuit_id}\")},\n                \"name\": f\"Circuit {self._circuit_id}\",\n                \"manufacturer\": \"Plum\",\n                \"via_device\": (DOMAIN, self._entry_id),\n            }\n        else:\n            return {\n                \"identifiers\": {(DOMAIN, self._entry_id)},\n                \"name\": \"Plum EcoMAX Boiler\",\n                \"manufacturer\": \"Plum\",\n            }\n</code></pre>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.available","title":"<code>available</code>  <code>property</code>","text":"<p>Checks if the entity is available.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if data is missing or NaN, True otherwise.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.device_class","title":"<code>device_class</code>  <code>property</code>","text":"<p>Returns the device class.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.device_info","title":"<code>device_info</code>  <code>property</code>","text":"<p>Links the sensor to the correct device (Boiler or specific Circuit).</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The device info dictionary.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.icon","title":"<code>icon</code>  <code>property</code>","text":"<p>Returns the icon.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.native_unit_of_measurement","title":"<code>native_unit_of_measurement</code>  <code>property</code>","text":"<p>Returns the unit of measurement.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.native_value","title":"<code>native_value</code>  <code>property</code>","text":"<p>Returns the sensor value with safety checks.</p> <p>CRITICAL FIX: Filters out 'NaN' (Not a Number) values to prevent HA crash.</p> <p>Returns:</p> Type Description <code>float | str | None</code> <p>float | str | None: The sanitized value.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.state_class","title":"<code>state_class</code>  <code>property</code>","text":"<p>Returns the state class (Measurement for numbers).</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.unique_id","title":"<code>unique_id</code>  <code>property</code>","text":"<p>Returns the unique ID of the sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p>"},{"location":"reference/sensor/#plum_ecomax.sensor.PlumEcomaxSensor.__init__","title":"<code>__init__(coordinator, entry, slug, config, circuit_id=None)</code>","text":"<p>Initializes the sensor.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>entry</code> <p>The config entry.</p> required <code>slug</code> <p>The parameter identifier.</p> required <code>config</code> <p>A tuple containing (unit, icon, device_class).</p> required <code>circuit_id</code> <p>Optional ID to link to a specific circuit device.</p> <code>None</code> Source code in <code>custom_components/plum_ecomax/sensor.py</code> <pre><code>def __init__(self, coordinator, entry, slug, config, circuit_id=None):\n    \"\"\"Initializes the sensor.\n\n    Args:\n        coordinator: The data update coordinator.\n        entry: The config entry.\n        slug: The parameter identifier.\n        config: A tuple containing (unit, icon, device_class).\n        circuit_id: Optional ID to link to a specific circuit device.\n    \"\"\"\n    super().__init__(coordinator)\n    self._slug = slug\n    self._attr_translation_key = slug\n\n    # Unpack configuration from const.py\n    self._unit = config[0]\n    self._icon = config[1]\n    self._device_class = config[2]\n\n    self._entry_id = entry.entry_id\n    self._circuit_id = circuit_id\n</code></pre>"},{"location":"reference/sensor/#plum_ecomax.sensor.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up sensor entities based on the configuration.</p> <p>Iterates through the <code>SENSOR_TYPES</code> defined in constants. If a sensor name contains 'circuit' or 'mixer' followed by a number, it is automatically assigned to that specific heating circuit device, provided that circuit is enabled in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>The Home Assistant instance.</p> required <code>entry</code> <code>ConfigEntry</code> <p>The config entry.</p> required <code>async_add_entities</code> <code>AddEntitiesCallback</code> <p>Callback to add entities.</p> required Source code in <code>custom_components/plum_ecomax/sensor.py</code> <pre><code>async def async_setup_entry(\n    hass: HomeAssistant,\n    entry: ConfigEntry,\n    async_add_entities: AddEntitiesCallback\n) -&gt; None:\n    \"\"\"Sets up sensor entities based on the configuration.\n\n    Iterates through the `SENSOR_TYPES` defined in constants.\n    If a sensor name contains 'circuit' or 'mixer' followed by a number,\n    it is automatically assigned to that specific heating circuit device,\n    provided that circuit is enabled in the configuration.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The config entry.\n        async_add_entities: Callback to add entities.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    selected_circuits = entry.data.get(CONF_ACTIVE_CIRCUITS, [])\n    entities = []\n\n    for slug, config in SENSOR_TYPES.items():\n        # Skip if the parameter is not present on the device\n        if slug not in coordinator.device.params_map:\n            continue\n\n        target_circuit_id = None\n        # Automatic circuit detection via Regex (e.g., tempcircuit1 -&gt; 1)\n        match = re.search(r'(circuit|mixer)(\\d+)', slug)\n\n        if match:\n            found_id = match.group(2)\n            # If it's a circuit sensor, verify if this circuit is enabled in config\n            if found_id in selected_circuits:\n                target_circuit_id = found_id\n            else:\n                continue \n\n        entities.append(PlumEcomaxSensor(coordinator, entry, slug, config, target_circuit_id))\n\n    if entities:\n        async_add_entities(entities)\n</code></pre>"},{"location":"reference/switch/","title":"Switch","text":""},{"location":"reference/switch/#plum_ecomax.switch","title":"<code>plum_ecomax.switch</code>","text":"<p>Switch platform for the Plum EcoMAX integration.</p> <p>This module handles binary switch entities. These are typically used for boolean parameters or simple on/off commands on the boiler, such as forcing the Domestic Hot Water (DHW) heating cycle.</p>"},{"location":"reference/switch/#plum_ecomax.switch.PlumEconetSwitch","title":"<code>PlumEconetSwitch</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>SwitchEntity</code></p> <p>Representation of a binary switch.</p> <p>This entity represents a writable boolean parameter on the device. It uses the data coordinator to read the current state and write changes back to the device (e.g., setting a value of 1 for On and 0 for Off).</p> Source code in <code>custom_components/plum_ecomax/switch.py</code> <pre><code>class PlumEconetSwitch(CoordinatorEntity, SwitchEntity):\n    \"\"\"Representation of a binary switch.\n\n    This entity represents a writable boolean parameter on the device.\n    It uses the data coordinator to read the current state and write\n    changes back to the device (e.g., setting a value of 1 for On and 0 for Off).\n    \"\"\"\n    _attr_has_entity_name = True\n\n    def __init__(self, coordinator, slug: str, name: str):\n        \"\"\"Initializes the switch entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            slug: The parameter identifier string.\n            name: The friendly name of the switch.\n        \"\"\"\n        super().__init__(coordinator)\n        self._slug = slug\n        self._log_name = name\n        self._attr_translation_key = slug\n        self._attr_unique_id = f\"{DOMAIN}_{slug}\"\n\n    @property\n    def is_on(self) -&gt; bool:\n        \"\"\"Checks if the switch is currently on.\n\n        Returns:\n            bool: True if the parameter value is 1, False otherwise.\n        \"\"\"\n        val = self.coordinator.data.get(self._slug)\n        try:\n            return int(val) == 1\n        except (ValueError, TypeError):\n            return False\n\n    async def async_turn_on(self, **kwargs: Any) -&gt; None:\n        \"\"\"Turns the switch on.\n\n        Writes '1' to the corresponding device parameter and updates the\n        local cache immediately.\n\n        Args:\n            **kwargs: Keyword arguments (unused).\n        \"\"\"\n        _LOGGER.info(f\"Turning ON {self._log_name} ({self._slug})\")\n        await self.coordinator.async_set_value(self._slug, 1)\n\n    async def async_turn_off(self, **kwargs: Any) -&gt; None:\n        \"\"\"Turns the switch off.\n\n        Writes '0' to the corresponding device parameter and updates the\n        local cache immediately.\n\n        Args:\n            **kwargs: Keyword arguments (unused).\n        \"\"\"\n        _LOGGER.info(f\"Turning OFF {self._log_name} ({self._slug})\")\n        await self.coordinator.async_set_value(self._slug, 0)\n</code></pre>"},{"location":"reference/switch/#plum_ecomax.switch.PlumEconetSwitch.is_on","title":"<code>is_on</code>  <code>property</code>","text":"<p>Checks if the switch is currently on.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the parameter value is 1, False otherwise.</p>"},{"location":"reference/switch/#plum_ecomax.switch.PlumEconetSwitch.__init__","title":"<code>__init__(coordinator, slug, name)</code>","text":"<p>Initializes the switch entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>slug</code> <code>str</code> <p>The parameter identifier string.</p> required <code>name</code> <code>str</code> <p>The friendly name of the switch.</p> required Source code in <code>custom_components/plum_ecomax/switch.py</code> <pre><code>def __init__(self, coordinator, slug: str, name: str):\n    \"\"\"Initializes the switch entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        slug: The parameter identifier string.\n        name: The friendly name of the switch.\n    \"\"\"\n    super().__init__(coordinator)\n    self._slug = slug\n    self._log_name = name\n    self._attr_translation_key = slug\n    self._attr_unique_id = f\"{DOMAIN}_{slug}\"\n</code></pre>"},{"location":"reference/switch/#plum_ecomax.switch.PlumEconetSwitch.async_turn_off","title":"<code>async_turn_off(**kwargs)</code>  <code>async</code>","text":"<p>Turns the switch off.</p> <p>Writes '0' to the corresponding device parameter and updates the local cache immediately.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments (unused).</p> <code>{}</code> Source code in <code>custom_components/plum_ecomax/switch.py</code> <pre><code>async def async_turn_off(self, **kwargs: Any) -&gt; None:\n    \"\"\"Turns the switch off.\n\n    Writes '0' to the corresponding device parameter and updates the\n    local cache immediately.\n\n    Args:\n        **kwargs: Keyword arguments (unused).\n    \"\"\"\n    _LOGGER.info(f\"Turning OFF {self._log_name} ({self._slug})\")\n    await self.coordinator.async_set_value(self._slug, 0)\n</code></pre>"},{"location":"reference/switch/#plum_ecomax.switch.PlumEconetSwitch.async_turn_on","title":"<code>async_turn_on(**kwargs)</code>  <code>async</code>","text":"<p>Turns the switch on.</p> <p>Writes '1' to the corresponding device parameter and updates the local cache immediately.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments (unused).</p> <code>{}</code> Source code in <code>custom_components/plum_ecomax/switch.py</code> <pre><code>async def async_turn_on(self, **kwargs: Any) -&gt; None:\n    \"\"\"Turns the switch on.\n\n    Writes '1' to the corresponding device parameter and updates the\n    local cache immediately.\n\n    Args:\n        **kwargs: Keyword arguments (unused).\n    \"\"\"\n    _LOGGER.info(f\"Turning ON {self._log_name} ({self._slug})\")\n    await self.coordinator.async_set_value(self._slug, 1)\n</code></pre>"},{"location":"reference/switch/#plum_ecomax.switch.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up Plum switch entities.</p> <p>Iterates through the <code>SWITCH_TYPES</code> configuration and creates an entity if the corresponding parameter exists on the device.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>The Home Assistant instance.</p> required <code>entry</code> <code>ConfigEntry</code> <p>The configuration entry.</p> required <code>async_add_entities</code> <code>AddEntitiesCallback</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/switch.py</code> <pre><code>async def async_setup_entry(\n    hass: HomeAssistant,\n    entry: ConfigEntry,\n    async_add_entities: AddEntitiesCallback,\n) -&gt; None:\n    \"\"\"Sets up Plum switch entities.\n\n    Iterates through the `SWITCH_TYPES` configuration and creates an entity\n    if the corresponding parameter exists on the device.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The configuration entry.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    entities = []\n\n    for slug, name in SWITCH_TYPES.items():\n        # We only create the entity if the parameter exists on the device\n        if slug in coordinator.device.params_map:\n            entities.append(PlumEconetSwitch(coordinator, slug, name))\n        else:\n            _LOGGER.debug(f\"Switch '{slug}' not found in device map, skipping.\")\n\n    async_add_entities(entities)\n</code></pre>"},{"location":"reference/water_heater/","title":"Water Heater","text":""},{"location":"reference/water_heater/#plum_ecomax.water_heater","title":"<code>plum_ecomax.water_heater</code>","text":"<p>Water Heater platform for the Plum EcoMAX integration.</p> <p>This module handles the Domestic Hot Water (DHW/ECS) tank control. It allows setting the target temperature, viewing the current temperature, and switching between operation modes (Off, Manual/Performance, Auto/Eco).</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater","title":"<code>PlumEcomaxWaterHeater</code>","text":"<p>               Bases: <code>CoordinatorEntity</code>, <code>WaterHeaterEntity</code></p> <p>Representation of the Domestic Hot Water (DHW) tank.</p> <p>This entity controls the hot water production. It reads dynamic limits (min/max supported temperature) directly from the device controller and supports distinct operation modes.</p> Source code in <code>custom_components/plum_ecomax/water_heater.py</code> <pre><code>class PlumEcomaxWaterHeater(CoordinatorEntity, WaterHeaterEntity):\n    \"\"\"Representation of the Domestic Hot Water (DHW) tank.\n\n    This entity controls the hot water production. It reads dynamic limits\n    (min/max supported temperature) directly from the device controller and\n    supports distinct operation modes.\n    \"\"\"\n\n    _attr_temperature_unit = UnitOfTemperature.CELSIUS\n    _attr_precision = PRECISION_WHOLE\n\n    # Supported features: Target Temperature and Operation Mode\n    _attr_supported_features = (\n        WaterHeaterEntityFeature.TARGET_TEMPERATURE | \n        WaterHeaterEntityFeature.OPERATION_MODE\n    )\n\n    # Supported modes (Off, Performance=Manual, Eco=Auto)\n    _attr_operation_list = [STATE_OFF, STATE_PERFORMANCE, STATE_ECO]\n\n    def __init__(self, coordinator, translation_key, current_slug, target_slug, min_slug, max_slug, mode_slug):\n        \"\"\"Initializes the water heater entity.\n\n        Args:\n            coordinator: The data update coordinator.\n            translation_key: The translation key (used as name).\n            current_slug: Slug for current temperature sensor.\n            target_slug: Slug for target temperature parameter.\n            min_slug: Slug for minimum allowed temperature.\n            max_slug: Slug for maximum allowed temperature.\n            mode_slug: Slug for operation mode.\n        \"\"\"\n        super().__init__(coordinator)\n        self._attr_translation_key = translation_key\n        self._current_slug = current_slug\n        self._target_slug = target_slug\n        self._min_slug = min_slug\n        self._max_slug = max_slug\n        self._mode_slug = mode_slug\n\n        self._attr_unique_id = f\"{DOMAIN}_{translation_key}\"\n        self._attr_has_entity_name = True\n\n    @property\n    def device_info(self) -&gt; DeviceInfo:\n        \"\"\"Links this entity to the dedicated DHW device.\n\n        Returns:\n            DeviceInfo: The device info dictionary.\n        \"\"\"\n        return DeviceInfo(\n            identifiers={(DOMAIN, \"plum_hdw\")},\n            name=\"DHW\",\n            manufacturer=\"Plum\",\n            model=\"DHW Manager\",\n        )\n\n    @property\n    def current_temperature(self) -&gt; Optional[float]:\n        \"\"\"Returns the current water temperature.\n\n        Includes checks for NaN (Not a Number) to prevent errors.\n\n        Returns:\n            float | None: Current temperature or None if invalid.\n        \"\"\"\n        val = self.coordinator.data.get(self._current_slug)\n        if val is None:\n            return None\n        try:\n            f_val = float(val)\n            if math.isnan(f_val): return None\n            return f_val\n        except (ValueError, TypeError):\n            return None\n\n    @property\n    def target_temperature(self) -&gt; Optional[float]:\n        \"\"\"Returns the current target temperature setpoint.\n\n        Returns:\n            float | None: The setpoint.\n        \"\"\"\n        val = self.coordinator.data.get(self._target_slug)\n        if val is None: return None\n        try: return float(val)\n        except: return None\n\n    @property\n    def min_temp(self) -&gt; float:\n        \"\"\"Returns the minimum supported temperature.\n\n        Fetches the limit dynamically from the device. Falls back to 20.0\n        if the value is unavailable or NaN.\n\n        Returns:\n            float: The limit value.\n        \"\"\"\n        val = self.coordinator.data.get(self._min_slug)\n        try: \n            f = float(val)\n            if math.isnan(f): return 20.0\n            return f\n        except: return 20.0\n\n    @property\n    def max_temp(self) -&gt; float:\n        \"\"\"Returns the maximum supported temperature.\n\n        Fetches the limit dynamically from the device. Falls back to 60.0\n        if the value is unavailable or NaN.\n\n        Returns:\n            float: The limit value.\n        \"\"\"\n        val = self.coordinator.data.get(self._max_slug)\n        try: \n            f = float(val)\n            if math.isnan(f): return 60.0\n            return f\n        except: return 60.0\n\n    @property\n    def current_operation(self) -&gt; Optional[str]:\n        \"\"\"Returns the current operation mode.\n\n        Maps internal Plum codes to Home Assistant states:\n        - 0 -&gt; Off\n        - 1 -&gt; Performance (Manual)\n        - 2 -&gt; Eco (Auto/Schedule)\n\n        Returns:\n            str: The current mode (STATE_OFF, STATE_PERFORMANCE, or STATE_ECO).\n        \"\"\"\n        raw_mode = self.coordinator.data.get(self._mode_slug)\n        # If raw_mode is None (startup), return Off for safety\n        if raw_mode is None:\n            return STATE_OFF\n\n        return PLUM_TO_HA_WATER_HEATER.get(raw_mode, STATE_OFF)\n\n    async def async_set_temperature(self, **kwargs) -&gt; None:\n        \"\"\"Sets the water target temperature.\n\n        Args:\n            **kwargs: Arguments containing ATTR_TEMPERATURE.\n        \"\"\"\n        temp = kwargs.get(ATTR_TEMPERATURE)\n        if temp is None:\n            return\n\n        _LOGGER.info(f\"Setting DHW target: {temp}\")\n        # Convert to int as Plum usually expects integers for setpoints\n        await self.coordinator.async_set_value(self._target_slug, int(temp))\n\n    async def async_set_operation_mode(self, operation_mode: str) -&gt; None:\n        \"\"\"Sets the operation mode.\n\n        Args:\n            operation_mode: The desired mode (e.g., \"performance\", \"eco\").\n        \"\"\"\n        target_val = HA_TO_PLUM_WATER_HEATER.get(operation_mode)\n\n        if target_val is not None:\n            _LOGGER.info(f\"Setting DHW mode: {operation_mode} -&gt; {target_val}\")\n            await self.coordinator.async_set_value(self._mode_slug, target_val)\n        else:\n            _LOGGER.error(f\"Unknown or unsupported DHW mode: {operation_mode}\")\n</code></pre>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.current_operation","title":"<code>current_operation</code>  <code>property</code>","text":"<p>Returns the current operation mode.</p> <p>Maps internal Plum codes to Home Assistant states: - 0 -&gt; Off - 1 -&gt; Performance (Manual) - 2 -&gt; Eco (Auto/Schedule)</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The current mode (STATE_OFF, STATE_PERFORMANCE, or STATE_ECO).</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.current_temperature","title":"<code>current_temperature</code>  <code>property</code>","text":"<p>Returns the current water temperature.</p> <p>Includes checks for NaN (Not a Number) to prevent errors.</p> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>float | None: Current temperature or None if invalid.</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.device_info","title":"<code>device_info</code>  <code>property</code>","text":"<p>Links this entity to the dedicated DHW device.</p> <p>Returns:</p> Name Type Description <code>DeviceInfo</code> <code>DeviceInfo</code> <p>The device info dictionary.</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.max_temp","title":"<code>max_temp</code>  <code>property</code>","text":"<p>Returns the maximum supported temperature.</p> <p>Fetches the limit dynamically from the device. Falls back to 60.0 if the value is unavailable or NaN.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The limit value.</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.min_temp","title":"<code>min_temp</code>  <code>property</code>","text":"<p>Returns the minimum supported temperature.</p> <p>Fetches the limit dynamically from the device. Falls back to 20.0 if the value is unavailable or NaN.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The limit value.</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.target_temperature","title":"<code>target_temperature</code>  <code>property</code>","text":"<p>Returns the current target temperature setpoint.</p> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>float | None: The setpoint.</p>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.__init__","title":"<code>__init__(coordinator, translation_key, current_slug, target_slug, min_slug, max_slug, mode_slug)</code>","text":"<p>Initializes the water heater entity.</p> <p>Parameters:</p> Name Type Description Default <code>coordinator</code> <p>The data update coordinator.</p> required <code>translation_key</code> <p>The translation key (used as name).</p> required <code>current_slug</code> <p>Slug for current temperature sensor.</p> required <code>target_slug</code> <p>Slug for target temperature parameter.</p> required <code>min_slug</code> <p>Slug for minimum allowed temperature.</p> required <code>max_slug</code> <p>Slug for maximum allowed temperature.</p> required <code>mode_slug</code> <p>Slug for operation mode.</p> required Source code in <code>custom_components/plum_ecomax/water_heater.py</code> <pre><code>def __init__(self, coordinator, translation_key, current_slug, target_slug, min_slug, max_slug, mode_slug):\n    \"\"\"Initializes the water heater entity.\n\n    Args:\n        coordinator: The data update coordinator.\n        translation_key: The translation key (used as name).\n        current_slug: Slug for current temperature sensor.\n        target_slug: Slug for target temperature parameter.\n        min_slug: Slug for minimum allowed temperature.\n        max_slug: Slug for maximum allowed temperature.\n        mode_slug: Slug for operation mode.\n    \"\"\"\n    super().__init__(coordinator)\n    self._attr_translation_key = translation_key\n    self._current_slug = current_slug\n    self._target_slug = target_slug\n    self._min_slug = min_slug\n    self._max_slug = max_slug\n    self._mode_slug = mode_slug\n\n    self._attr_unique_id = f\"{DOMAIN}_{translation_key}\"\n    self._attr_has_entity_name = True\n</code></pre>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.async_set_operation_mode","title":"<code>async_set_operation_mode(operation_mode)</code>  <code>async</code>","text":"<p>Sets the operation mode.</p> <p>Parameters:</p> Name Type Description Default <code>operation_mode</code> <code>str</code> <p>The desired mode (e.g., \"performance\", \"eco\").</p> required Source code in <code>custom_components/plum_ecomax/water_heater.py</code> <pre><code>async def async_set_operation_mode(self, operation_mode: str) -&gt; None:\n    \"\"\"Sets the operation mode.\n\n    Args:\n        operation_mode: The desired mode (e.g., \"performance\", \"eco\").\n    \"\"\"\n    target_val = HA_TO_PLUM_WATER_HEATER.get(operation_mode)\n\n    if target_val is not None:\n        _LOGGER.info(f\"Setting DHW mode: {operation_mode} -&gt; {target_val}\")\n        await self.coordinator.async_set_value(self._mode_slug, target_val)\n    else:\n        _LOGGER.error(f\"Unknown or unsupported DHW mode: {operation_mode}\")\n</code></pre>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.PlumEcomaxWaterHeater.async_set_temperature","title":"<code>async_set_temperature(**kwargs)</code>  <code>async</code>","text":"<p>Sets the water target temperature.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arguments containing ATTR_TEMPERATURE.</p> <code>{}</code> Source code in <code>custom_components/plum_ecomax/water_heater.py</code> <pre><code>async def async_set_temperature(self, **kwargs) -&gt; None:\n    \"\"\"Sets the water target temperature.\n\n    Args:\n        **kwargs: Arguments containing ATTR_TEMPERATURE.\n    \"\"\"\n    temp = kwargs.get(ATTR_TEMPERATURE)\n    if temp is None:\n        return\n\n    _LOGGER.info(f\"Setting DHW target: {temp}\")\n    # Convert to int as Plum usually expects integers for setpoints\n    await self.coordinator.async_set_value(self._target_slug, int(temp))\n</code></pre>"},{"location":"reference/water_heater/#plum_ecomax.water_heater.async_setup_entry","title":"<code>async_setup_entry(hass, entry, async_add_entities)</code>  <code>async</code>","text":"<p>Sets up the water heater entity based on the configuration.</p> <p>It iterates through the defined <code>WATER_HEATER_TYPES</code> and checks if the required parameters exist in the device map before creating the entity.</p> <p>Parameters:</p> Name Type Description Default <code>hass</code> <code>HomeAssistant</code> <p>The Home Assistant instance.</p> required <code>entry</code> <code>Any</code> <p>The config entry.</p> required <code>async_add_entities</code> <code>AddEntitiesCallback</code> <p>Callback to add entities to Home Assistant.</p> required Source code in <code>custom_components/plum_ecomax/water_heater.py</code> <pre><code>async def async_setup_entry(\n    hass: HomeAssistant,\n    entry: Any,\n    async_add_entities: AddEntitiesCallback,\n) -&gt; None:\n    \"\"\"Sets up the water heater entity based on the configuration.\n\n    It iterates through the defined `WATER_HEATER_TYPES` and checks if\n    the required parameters exist in the device map before creating the entity.\n\n    Args:\n        hass: The Home Assistant instance.\n        entry: The config entry.\n        async_add_entities: Callback to add entities to Home Assistant.\n    \"\"\"\n    coordinator = hass.data[DOMAIN][entry.entry_id]\n    entities = []\n\n    _LOGGER.info(\"Starting water heater setup...\")\n\n    for key, slugs in WATER_HEATER_TYPES.items():\n        current_temp, target_temp, min_temp, max_temp, mode_slug = slugs\n\n        has_current = current_temp in coordinator.device.params_map\n        has_target = target_temp in coordinator.device.params_map\n\n        if has_current and has_target:\n            _LOGGER.info(f\"\u2705 Creating Water Heater '{key}' (Parameters found).\")\n            entities.append(\n                PlumEcomaxWaterHeater(\n                    coordinator, \n                    key, \n                    current_temp, target_temp, min_temp, max_temp, mode_slug\n                )\n            )\n        else:\n            _LOGGER.error(\n                f\"\u274c Failed to create Water Heater '{key}'. \"\n                f\"Missing parameters in device_map.json: \"\n                f\"Temp='{current_temp}' (Present={has_current}), \"\n                f\"Target='{target_temp}' (Present={has_target})\"\n            )\n\n    async_add_entities(entities)\n</code></pre>"}]}